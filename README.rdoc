= Ruby OpenStack

== Description

Ruby Openstack Compute, Object-Store, Block Storage and Network (Quantum) bindings for the OpenStack API.
a
http://api.openstack.org/api-reference.html

Currently supports both v1.0 and v2.0 (keystone) auth.

Use OpenStack::Connection.create to get a handle to an OpenStack service - set the :service_type parameter to 'compute', 'object-store', 'volume' or 'network' (defaults to 'compute'). If the requested service is not deployed the gem will throw a OpenStack::Exception::NotImplemented (501) - e.g. :service_type is 'object-store' but swift service isn't deployed.

The OpenStack::Connection.create class method is a factory constructor which will return the appropriate Connection object, depending on the ':service_type' parameter passed with the options hash: set to either 'compute', 'volume', or  'object-store' (defaults to 'compute') - see below for examples.

Other parameters for the create method:

* :auth_url - the OpenStack service provider specific authentication url endpoint.
* :auth_method - the type of authentication to be used with the above auth_url - either 'password' (username/password, 'key' (ec2 style key/private key)  or 'rax-kskey'.
* :authtenant_name OR :authtenant_id - one of these MUST be specified when talking to a v2 authentication endpoint (keystone) - depending on whether you use tenant name (or tenant ID). Passing only :authtenant will result in that parameter being used as tenant name.
* :username - the username or public key (depending on auth_method)
* :api_key - the password or private key (denending on auth_method).

=== Try it out:

  sudo gem install openstack
    [sudo] password for herp:
    Successfully installed openstack-1.0.0

  [herp@name lib]$ irb -rubygems
  irb(main):001:0> require 'openstack'
    => true

  irb(main):002:0> os = OpenStack::Connection.create({:username => "herp@derp.net", :api_key=>"1234abcd", :auth_method=>"password", :auth_url => "https://regionerer-g.go-bar.identity.dacloudfoo.herpy:13327/v2.0/", :authtenant_name =>"herp@derp.net-default-tenant", :service_type=>"compute"})

    => #<OpenStack::Compute::Connection:0xb7339070 @connection=#<OpenStack::Connection:0xb73392dc @service_scheme="https", @auth_host="regionerer-g.go-bar.identity.dacloudfoo.herpy", @http={}, @service_name=nil, @authuser="herp@derp.net", @proxy_port=nil, @auth_path="/v2.0/", @authtenant={:type=>"tenantName", :value=>"herp@derp.net-default-tenant"}, @service_port=443, @authkey="1235abcd", @authok=true, @service_type="compute", @auth_method="password", @auth_scheme="https", @service_host="az-2.region-a.geo-1.dacloudfoo.herpy", @is_debug=nil, @proxy_host=nil, @service_path="/v1.1/482195756462871", @auth_port=35357, @auth_url="https://regionerer-g.go-bar.identity.dacloudfoo.herpy:13327/v2.0/", @region=nil, @authtoken="Auth_543254fdsasabd546543a3", @retry_auth=nil>>

  irb(main):003:0> os.servers
    => []

  irb(main):004:0> os = OpenStack::Connection.create({:username => "AWHFDADHJ32EL6V23GFK", :api_key=>"jd823jFDJEY2/82jfhYteG52AKJAUEY184JHRfeR", :auth_method=> "key", :auth_url => "https://regionerer-g.go-bar.identity.dacloudfoo.herpy:13327/v2.0/", :authtenant_id =>"482195756462871", :service_type=>"object-store"})

    => #<OpenStack::Swift::Connection:0xb72ff2a8 @connection=#<OpenStack::Connection:0xb72ff460 @service_scheme="https", @auth_host="regionerer-g.go-bar.identity.dacloudfoo.herpy", @http={}, @service_name=nil, @authuser="AWHFDADHJ32EL6V23GFK", @proxy_port=nil, @auth_path="/v2.0/", @authtenant={:type=>"tenantId", :value=>"482195756462871"}, @service_port=443, @authkey="jd823jFDJEY2/82jfhYteG52AKJAUEY184JHRfeR", @authok=true, @service_type="object-store", @auth_method="key", @auth_scheme="https", @service_host="region-a.geo-1.objects.dacloudfoo.herpy", @is_debug=nil, @proxy_host=nil, @service_path="/v1.0/482195756462871", @auth_port=35357, @auth_url="https://regionerer-g.go-bar.identity.dacloudfoo.herpy:13327/v2.0/", @region=nil, @authtoken="Auth_543254fdsasabd546543a3", @retry_auth=nil>>

  irb(main):006:0> os.containers
    => ["herpy_Foo_container", "derpy_bar_bucket"]

  irb(main):003:0> os.connection.regions_list
    => {"region-a.geo-1" => [ {:service=>"object-store", :versionId=>"1.0"}, {:service=>"identity", :versionId=>"2.0"}],
        "region-b.geo-1"=>[{:service=>"identity", :versionId=>"2.0"}],
        "az-2.region-a.geo-1"=>[{:service=>"image", :versionId=>"1.0"}, {:service=>"volume", :versionId=>"1.1"}, {:service=>"compute", :versionId=>"1.1"}],
        "az-1.region-a.geo-1"=>[{:service=>"image", :versionId=>"1.0"}, {:service=>"volume", :versionId=>"1.1"}, {:service=>"compute", :versionId=>"1.1"}]}

  irb(main):005:0> os.connection.regions_list["region-a.geo-1"]
    => [{:service=>"object-store", :versionId=>"1.0"}, {:service=>"identity", :versionId=>"2.0"}]


== Examples

== For Compute:

See the class definitions for documentation on specific methods and operations.

  require 'openstack'

  os = OpenStack::Connection.create(:username => USERNAME, :api_key => API_KEY, :authtenant => TENANT, :auth_url => API_URL, :service_type => "compute")

  # Get a listing of all current servers
  >> os.servers
  => [{:name=>"Server1", :id=>110917}]

  # Access a specific server
  >> server = os.server(110917)
  >> server.name
  => "Server1"

  # See what type of server this is
  >> server.flavor.name
  => "256 server"
  >> server.image.name
  => "Ubuntu 8.04.2 LTS (hardy)"

  # Soft-reboot the server
  >> server.reboot
  => true

  # Create a new 512MB CentOS 5.2 server.  The root password is returned in the adminPass method.
  >> image = os.get_image(8)
  => #<OpenStack::Compute::Image:0x1014a8060 ...>, status"ACTIVE"
  >> image.name
  => "CentOS 5.2"
  >> flavor = os.get_flavor(2)
  => #<OpenStack::Compute::Flavor:0x101469130 @disk=20, @name="512 server", @id=2, @ram=512>
  >> flavor.name
  => "512 server"
  >> newserver = os.create_server(:name => "New Server", :imageRef => image.id, :flavorRef => flavor.id)
  => #<OpenStack::Compute::Server:0x101433f08 ....
  >> newserver.status
  => "BUILD"
  >> newserver.progress
  => 0
  >> newserver.adminPass
  => "NewServerMbhzUnO"
  >> newserver.refresh
  => true
  >> newserver.progress
  => 12

  # Create a new server and specify the keyname and security_groups to be used (dependent on provider support for these API extensions):
  >> server = os.create_server({:imageRef=>14075, :flavorRef=>100, :key_name=>"my_default_key", :security_groups=>["test", "default"], :name=>"marios_server"})
  => #<OpenStack::Compute::Server:0x101433f08 ....
  >> server.key_name
  => "my_default_key"
  >> server.security_groups

  # Delete the new server
  >> newserver.delete!
  => true

=== Compute API extensions.

  # Get info on extensions offered by the given OpenStack provider:
  >> os.api_extensions
  => { :os-keypairs     =>  { :links=>[], :updated=>"2011-08-08T00:00:00+00:00", :description=>"Keypair Support",
                              :namespace=>"http://docs.openstack.org/ext/keypairs/api/v1.1", :name=>"Keypairs",
                              :alias=>"os-keypairs" },
       :os-floating_ips =>  { :links=>[], :updated=>"2011-06-16T00:00:00+00:00", :description=>"Floating IPs support",
                              :namespace=>"http://docs.openstack.org/ext/floating_ips/api/v1.1", :name=>"Floating_ips", :alias=>"os-floating-ips"},
        ... }

==== Compute API keypairs extension

  # Get list of keypairs for current tenant/account:
  >> os.keypairs
  => { :key_one => {  :fingerprint  =>  "3f:12:4d:d1:54:f1:f4:3f:fe:a8:12:ec:1a:fb:35:b2",
                      :public_key   =>  "ssh-rsa AAAAB3Nza923kJ  ...
                      :name         =>  "key_one"},
       :key_two =>  { ... },
      ... }

  # Create new keypair:
  >> os.create_keypair({:name=>"test_key"})
  => {  :name         =>  "test_key",
        :fingerprint  =>  "f1:f3:a2:d3:ca:75:da:f1:06:f4:f7:dc:cc:7d:e1:ca",
        :user_id      =>  "dev_41247879706381",$
        :public_key   =>  "ssh-rsa AAAAB3NzaC1y    ...
        :private_key  =>  "-----BEGIN RSA PRIVATE KEY-----\nMIICXwIBA ... -----END RSA PRIVATE KEY-----\n"
     }

  # Import keypair:
  >> os.create_keypair({:name=>"test_key_imported", :public_key=>"sh-rsa AAAAB3Nza923kJ  ..."})
  => {  :name         =>  "test_key_imported",
        :fingerprint  =>  "f1:f3:a2:d3:ca:75:da:f1:06:f4:f7:dc:cc:7d:e1:ca",
        :user_id      =>  "dev_41247879706381",$
        :public_key   =>  "ssh-rsa AAAAB3Nza ...
     }

  # Delete Keypair:
  >> os.delete_keypair("test_key_imported")
  => true

==== Compute API security groups extension

  # List all security groups:
  >> os.security_groups
  =>  { "1381" => { :tenant_id=>"12345678909876", :id=>1381, :name=>"default", :description=>"default",
                    :rules=> [
                        {:from_port=>22, :group=>{}, :ip_protocol=>"tcp", :to_port=>22,
                         :parent_group_id=>1381, :ip_range=>{:cidr=>"0.0.0.0/0"}, :id=>4902},
                             ]
                   },
        "1234" => { ... } }

  # Get a specific security group:
  >> os.security_group(1381)
  =>  { "1381" => { :tenant_id=>"12345678909876", :id=>1381, :name=>"default", :description=>"default",
                    :rules=> [
                        {:from_port=>22, :group=>{}, :ip_protocol=>"tcp", :to_port=>22,
                         :parent_group_id=>1381, :ip_range=>{:cidr=>"0.0.0.0/0"}, :id=>4902},
                             ]
                   }}

  #Create a new security group:
  >> os.create_security_group("devel_group", "all development machines")
  => {"9573"=>{:rules=>[], :tenant_id=>"46871569847393", :id=>9573, :name=>"devel_group", :description=>"all development machines"}}

  #Create a new security group rule - first param is id of the security group for this rule. Instead of :cidr you may specify :group_id to use another group as source:
  >> os.create_security_group_rule(9567, {:ip_protocol=>"tcp", :from_port=>"123", :to_port=>"123", :cidr=>"192.168.0.1/16" })
  => => {"27375"=>{:from_port=>123, :group=>{}, :ip_protocol=>"tcp", :to_port=>123, :parent_group_id=>9573, :ip_range=>{:cidr=>"192.168.0.1/16"}, :id=>27375}}

  #Delete a security group rule:
  >> os.delete_security_group_rule(27375)
  => true

  #Delete a security group:
  >>  os.delete_security_group(9571)
  => true

==== Compute API volumes extension:

  #Attach a volume to a server - params in order are: server_id, volume_id, attachment_point

  >> os.attach_volume(704289, 90805, "/dev/sde")
  => true

  #List attachments for a server:

  >> os.list_attachments 704289
  => {:volumeAttachments=>[{:device=>"/dev/sde", :serverId=>704289, :id=>90805, :volumeId=>90805}]}

  #Detach volume from server - params in order are server_id and attachment_id
  >> os.detach_volume(704289, 90805)
  => true

==== Compute API floating IPs extension:

  #List all floating IPs
  irb(main):003:0> nova.get_floating_ips
  => [#<OpenStack::Compute::FloatingIPAddress:0x000000031d07b0 @fixed_ip=nil, @id=3714, @instance_id=nil, @ip="15.185.110.129", @pool=nil>, #<OpenStack::Compute::FloatingIPAddress:0x00000003210478 @fixed_ip=nil, @id=4034, @instance_id=nil, @ip="15.185.111.193", @pool=nil>]

  #Get a specific floating IP:
  irb(main):004:0> nova.get_floating_ip(4034)
  => #<OpenStack::Compute::FloatingIPAddress:0x00000002349958 @fixed_ip=nil, @id=4034, @instance_id=nil, @ip="15.185.111.193", @pool=nil>

  #Create floating IP - optionally specifying 'pool' as {:pool=>"foo"}
  irb(main):003:0> addr = nova.create_floating_ip
  => #<OpenStack::Compute::FloatingIPAddress:0x00000001882c68 @fixed_ip=nil, @id=3932, @instance_id=nil, @ip="15.185.111.91", @pool=nil>

  #Delete a floating IP by ID:
  irb(main):004:0> nova.delete_floating_ip(addr.id)
  => true

  #Attach floating IP to running server - hash param speciried :server_id and :ip_id
  irb(main):014:0> nova.attach_floating_ip({:server_id=>"73c12492-e966-4af0-a5e9-b5d1e436fe61", :ip_id=>"3932"})
  => true

  #Detach floating IP from server - hash param as above for attach
  irb(main):014:0> nova.detach_floating_ip({:server_id=>"73c12492-e966-4af0-a5e9-b5d1e436fe61", :ip_id=>"3932"})
  => true


== Examples for Volumes and Snaphots:

  #NOTE - attach/detach operations are implemented for the compute service as the OS API defines these operations as extensions to Openstack Compute.

  vs = OpenStack::Connection.create({:username => "username", :api_key=>"pass", :auth_url => "https://region-a.geo-1.identity.hpcloudsvc.com:35357/v2.0/", :authtenant=>"username-default-tenant", :service_type=>"volume"})

  # Create a volume: - MUST specify display_name and size parameters... optional params are {:display_description, :metadata=>{:key=>val, ...}, :availability_zone, :volume_type }

  >> volume = vs.create_volume({:display_name=>"marios volume", :size=>1, :display_description=>"some new volume bla"})
  => #<OpenStack::Volume::Volume:0x8a3c534 @id=90805, @display_name="marios volume", @display_description="some new volume bla", @size=1, @volume_type=nil, @metadata={}, @availability_zone="nova", @snapshot_id="", @attachments=[{}], @created_at="2012-11-15 13:51:23">

  >> volume.size
  => 1

  >> volume.attachments
  => [{}]

  # List volumes:

  >> vs.list_volumes                    #aliased as just 'volumes' ... vs.volumes
  => [#<OpenStack::Volume::Volume:0x8aad2e8 @id=90625, @display_name="marios volume", @display_description="attach test volume", @size=1, @volume_type=nil, @metadata={}, @availability_zone="nova", @snapshot_id="", @attachments=[{}], @created_at="2012-11-15 09:54:58">, #<OpenStack::Volume::Volume:0x8aad144 @id=90805, @display_name="marios volume", @display_description="some new volume bla", @size=1, @volume_type=nil, @metadata={}, @availability_zone="nova", @snapshot_id="", @attachments=[{}], @created_at="2012-11-15 13:51:23">]

  # Get a particular volume - must specify ID:

  >> vs.get_volume(90625)                #aliased as 'volume'
  => #<OpenStack::Volume::Volume:0x8abd4a4 @id=90625, @display_name="marios volume", @display_description="attach test volume", @size=1, @volume_type=nil, @metadata={}, @availability_zone="nova", @snapshot_id="", @attachments=[{}], @created_at="2012-11-15 09:54:58">

  # Delete a volume:

  >> vs.delete_volume(90805)
  => true

  # Create a snapshot: - must specify display_name and volume_id parameters... optionally also :display_description
  >> vs.create_snapshot({:volume_id=>"3b38b570-a4ff-4444-984a-3566cbdc8ab2", :display_name=>"marios_snapshot"})
  => #<OpenStack::Volume::Snapshot:0xa0cfea4 @id=223, @display_name="marios_snapshot", @display_description=nil, @volume_id="3b38b570-a4ff-4444-984a-3566cbdc8ab2", @status="creating", @size=1, @created_at="2013-01-23 14:25:02.654217">

  # List snapshots: - aliased as just 'snapshots' ... vs.snapshots
  >> vs.list_snapshots
  => [#<OpenStack::Volume::Snapshot:0x9a6e4fc @id="0e76dacb-2fcf-4565-84a3-aa3d7bd16224", @display_name="marios_snapshot", @display_description=nil, @volume_id="3b38b570-a4ff-4444-984a-3566cbdc8ab2", @status="creating", @size=1, @created_at="2013-01-23T14:18:13.000000">]

  # Get a specific snapshot: - aliased as 'snapshot'
  >> vs.get_snapshot("0e76dacb-2fcf-4565-84a3-aa3d7bd16224")
  => #<OpenStack::Volume::Snapshot:0x9a890b8 @id="0e76dacb-2fcf-4565-84a3-aa3d7bd16224", @display_name="marios_snapshot", @display_description=nil, @volume_id="3b38b570-a4ff-4444-984a-3566cbdc8ab2", @status="creating", @size=1, @created_at="2013-01-23T14:18:13.000000">

  # Delete a snapshot:
  >> vs.delete_snapshot("0e76dacb-2fcf-4565-84a3-aa3d7bd16224")
  => true

== Examples for Object-Store:


  os = OpenStack::Connection.create(:username => USERNAME, :api_key => API_KEY, :authtenant => TENANT, :auth_url => API_URL, :service_type => "object-store")

  # Get info on container count and bytes:
  >> os.get_info
  => {:count=>2, :bytes=>495041}

  # Get list of containers under this account:
  >> os.containers
  => ["another_containerfoo", "marios_test_container"]

  # Get details of containers under this account:
  >> os.containers_detail
  =>=> {"another_containerfoo"=>{:count=>"3", :bytes=>"1994"}, "marios_test_container"=>{:count=>"2", :bytes=>"493047"}}

  # Check if a container exists
  >> os.container_exists?("no_such_thing")
  => false

  # Create new container
  >> os.create_container("foo")
  => => #<OpenStack::Swift::Container:0xb7275c38  ...... (rest of OpenStack::Swift::Container object)

  # Delete container
  >> os.delete_container("foo")
  => true

  # Get a container (OpenStack::Swift::Container object):
  >> cont = os.container("foo")
  => #<OpenStack::Swift::Container:0xb7262124 ...... (rest of OpenStack::Swift::Container object)

  # Retrieve container metadata:
  >> cont.container_metadata
  =>{:count=>"2", :bytes=>"493047", :metadata=>{"foo"=>"bar", "author"=>"foobar", "jj"=>"foobar", "date"=>"today", "owner"=>"foo"}}

  # Retrieve user defined metadata:
  >> cont.metadata
  => {"foo"=>"bar", "author"=>"foobar", "jj"=>"foobar", "date"=>"today", "owner"=>"foo"}

  # Set user defined metadata:
  >> cont.set_metadata({"X-Container-Meta-Author"=> "msa", "version"=>"1.2", :date=>"today"})
  => true

  # Get list of objects:
  >> cont.objects
  => ["fosdem2012.pdf", "moved_object"]

  # Get list of objects with details:
  >> cont.objects_detail
  => {"fosdem2012.pdf"=>{:bytes=>"493009", :content_type=>"application/json", :hash=>"494e444f92a8082dabac80a74cdf2c3b", :last_modified=>"2012-04-26T09:22:51.611230"}, "moved_object"=>{:bytes=>"38", :content_type=>"application/json", :hash=>"a7942f97fe6bd34920a4f61fe5e604a5", :last_modified=>"2012-04-26T09:35:33.839920"}}

  # Check if container is empty:
  >> cont.empty?
  => false

  # Check if object exists:
  >> cont.object_exists?("foo")
  => false

  # Create new object
  >> new_obj = cont.create_object("foo", {:metadata=>{"herpy"=>"derp"}, :content_type=>"text/plain"}, "this is the data")  [can also supply File.open(/path/to/file) and the data]
  => #<OpenStack::Swift::StorageObject:0xb72fdac0  ... etc

  # Delete object
  >> cont.delete_object("foo")
  => true

  # Get handle to an OpenStack::Swift::StorageObject Object
  >> obj = cont.object("foo")
  => #<OpenStack::Swift::StorageObject:0xb72fdac0  ... etc

  # Get object metadata
  >> obj.object_metadata
  =>

  # Get user defined metadata pairs
  >> obj.metadata
  =>

  # Get data (non streaming - returned as a String)
  >> obj.data
  => "This is the text stored in the file"

  # Get data (streaming - requires a block)
  >> data = ""; object.data_stream do |chunk| data += chunk end
  => #<Net::HTTPOK 200 OK readbody=true>
  >> data
  => "This is the text stored in the file"

  # Set user defined metadata
  >> obj.set_metadata({:foo=>"bar", "X-Object-Meta-herpa"=>"derp", "author"=>"me"})
  => true

  # (Over)Write object data
  >> object.write("This is new data")
  => true
  >> object.data
  => "This is new data"

  # Copy object:
  >>copied = obj.copy('copied_object', "destination_container", {:content_type=>"text/plain", :metadata=>{:herp=>"derp", "X-Object-Meta-foo"=>"bar} } )
  => #<OpenStack::Swift::StorageObject:0xb728974c  ..... etc

  # Move object: (copy and then delete original):
  >> moved = obj.move('moved_object', "destination_container", {:content_type=>"text/plain", :metadata=>{:herp=>"derp", "X-Object-Meta-foo"=>"bar"} } )
  =>  #<OpenStack::Swift::StorageObject:0xb7266bd4 ...
  >> moved.metadata
  => {"foo"=>"bar", "herp"=>"derp", "herpy"=>"derp"}
  >> obj.metadata
  => OpenStack::Exception::ItemNotFound: The resource could not be found


== Examples for Network (Quantum):

  quantum = OpenStack::Connection.create({:username => "admin",  :api_key=>"le-password", :auth_method=>"password",  :auth_url => "http://192.168.1.21:5000/v2.0/", :authtenant_name =>"admin",  :service_type=>"network"})

  #Create a network:
  >> net2 = quantum.create_network("my_net")
  => #<OpenStack::Network::Network:0xa8aff70 @id="6b09a5b3-02d3-4996-9933-4792bd4ca11e",@name="my_net", @admin_state_up=true, @status="ACTIVE", @subnets=[], @shared=false, @tenant_id="7be215d541ea4db4a23b3a84b0882408">

  #List networks:
  >> quantum.networks
  => [#<OpenStack::Network::Network:0xa7c8f94 @id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="net_1363343212", @admin_state_up=true, @status="ACTIVE",
@subnets=["34ea9f1e-d71a-48bd-89b0-af2f5c051912","7780f890-8334-43a1-934c-f1ce5edc4561"], @shared=false, @tenant_id="7be215d541ea4db4a23b3a84b0882408">, #<OpenStack::Network::Network:0xa7c8ef4 @id="1cfad632-3473-4c5b-b2d3-405cc3093286", @name="net_1363344435", @admin_state_up=true, @status="ACTIVE", @subnets=["c4293c24-07d0-47dc-bead-ec8d3934b8db"], @shared=false, @tenant_id="7be215d541ea4db4a23b3a84b0882408">]

  >> net1 = quantum.network("b4abfaff-9e24-4192-9219-a4a60819aba2")
  => #<OpenStack::Network::Network:0xa7f28e4 @id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="net_1363343212", @admin_state_up=true, @status="ACTIVE", @subnets=["34ea9f1e-d71a-48bd-89b0-af2f5c051912", "7780f890-8334-43a1-934c-f1ce5edc4561"], @shared=false, @tenant_id="7be215d541ea4db4a23b3a84b0882408">

  #Delete a Network:
  >> quantum.delete_network("6b09a5b3-02d3-4996-9933-4792bd4ca11e")
  => true

  #Create a Subnet:
  >> subnet1 = quantum.create_subnet("b4abfaff-9e24-4192-9219-a4a60819aba2","192.168.1.0/24")
  => #<OpenStack::Network::Subnet:0xa772a2c @id="e978da1c-9c95-4e58-b4b6-4dcce4640a7f", @network_id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="", @ip_version=4, @cidr="192.168.1.0/24", @gateway_ip="192.168.1.1", @dns_nameservers=[], @allocation_pools=[{"start"=>"192.168.1.2", "end"=>"192.168.1.254"}], @host_routes=[], @enable_dhcp=true, @tenant_id="7be215d541ea4db4a23b3a84b0882408">

  #List Subnets:
  >> quantum.subnets
  => [#<OpenStack::Network::Subnet:0xa850958 @id="34ea9f1e-d71a-48bd-89b0-af2f5c051912", @network_id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="", @ip_version=4, @cidr="123.123.0.0/16", @gateway_ip="123.123.0.1", @dns_nameservers=[], @allocation_pools=[{"start"=>"123.123.0.2", "end"=>"123.123.255.254"}], @host_routes=[], @enable_dhcp=true, @tenant_id="7be215d541ea4db4a23b3a84b0882408">, #<OpenStack::Network::Subnet:0xa850868 @id="7780f890-8334-43a1-934c-f1ce5edc4561", @network_id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="", @ip_version=4, @cidr="192.168.1.0/24", @gateway_ip="192.168.1.1", @dns_nameservers=[], @allocation_pools=[{"start"=>"192.168.1.2", "end"=>"192.168.1.254"}], @host_routes=[], @enable_dhcp=true, @tenant_id="7be215d541ea4db4a23b3a84b0882408">]

  >> subnet1 = quantum.subnet("34ea9f1e-d71a-48bd-89b0-af2f5c051912")
  => #<OpenStack::Network::Subnet:0xa88ec1c @id="34ea9f1e-d71a-48bd-89b0-af2f5c051912", @network_id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="", @ip_version=4, @cidr="123.123.0.0/16", @gateway_ip="123.123.0.1", @dns_nameservers=[], @allocation_pools=[{"start"=>"123.123.0.2", "end"=>"123.123.255.254"}], @host_routes=[], @enable_dhcp=true, @tenant_id="7be215d541ea4db4a23b3a84b0882408">

  #Delete a Subnet:
  >> quantum.delete_subnet("89136e4d-da26-4495-9384-0fd1309e274a")
  => true

  #Create a Port:
  >> created_port = quantum.create_port(network.id, {"fixed_ips"=>[{"subnet_id"=>subnet.id}], "device_id"=>machine.id})
  => #<OpenStack::Network::Port:0x95a833c @id="d601db9e-c936-4811-904a-bb5a27d105f3", @network_id="c4dfe90e-a7ce-41f7-b9b2-2f9773f42a6b", @name="", @admin_state_up=true, @status="ACTIVE", @mac_address="fa:16:3e:f4:e8:bc", @fixed_ips=[{"subnet_id"=>"f78bfc05-ead0-40a6-8325-a35eb2b535c3", "ip_address"=>"10.0.0.4"}], @device_id="fe4022fa-a77c-4adf-be45-6e069fb3a314", @device_owner="", @tenant_id="7be215d541ea4db4a23b3a84b0882408">

  #List Ports:
  >> quantum.ports
  => [#<OpenStack::Network::Port:0xa73bdd8 @id="f0db2c95-9449-4eb3-8b12-c66b23c8de41", @network_id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="", @admin_state_up=true, @status="ACTIVE", @mac_address="fa:16:3e:7e:e0:1b", @fixed_ips=[{"subnet_id"=>"34ea9f1e-d71a-48bd-89b0-af2f5c051912", "ip_address"=>"123.123.0.2"}], @device_id="4357665c-e2fe-4bf0-8a69-b531d11add2d", @device_owner="compute:nova", @tenant_id="7be215d541ea4db4a23b3a84b0882408">, #<OpenStack::Network::Port:0xa73bcac @id="93c210cd-b086-49e1-aa12-d207aa28a981", @network_id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="", @admin_state_up=true, @status="ACTIVE", @mac_address="fa:16:3e:08:eb:92", @fixed_ips=[{"subnet_id"=>"34ea9f1e-d71a-48bd-89b0-af2f5c051912", "ip_address"=>"123.123.0.3"}], @device_id="5a114ba2-4f49-4655-93f9-96954632cb67", @device_owner="compute:nova", @tenant_id="7be215d541ea4db4a23b3a84b0882408">]

  >> port1 = quantum.port("f0db2c95-9449-4eb3-8b12-c66b23c8de41")
  => #<OpenStack::Network::Port:0xa70f51c @id="f0db2c95-9449-4eb3-8b12-c66b23c8de41", @network_id="b4abfaff-9e24-4192-9219-a4a60819aba2", @name="", @admin_state_up=true, @status="ACTIVE", @mac_address="fa:16:3e:7e:e0:1b", @fixed_ips=[{"subnet_id"=>"34ea9f1e-d71a-48bd-89b0-af2f5c051912", "ip_address"=>"123.123.0.2"}], @device_id="4357665c-e2fe-4bf0-8a69-b531d11add2d", @device_owner="compute:nova", @tenant_id="7be215d541ea4db4a23b3a84b0882408">

  #Delete a Port:
  >> quantum.delete_port("f0db2c95-9449-4eb3-8b12-c66b23c8de41")
  => true

== Authors

By Marios Andreou (marios@redhat.com), Dan Prince <dprince@redhat.com>, Naveed Massjouni <naveedm9@gmail.com>

Initial code checkin on May 23rd 2012 - code refactored from and based on the Rackspace Cloud Servers gem
(https://github.com/rackspace/ruby-openstack-compute) and Rackspace Cloud Files gem (https://github.com/rackspace/ruby-cloudfiles).

== License

See COPYING for license information.
